<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymarket Watchlist</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='75' fill='%230066ff'>ðŸ“ˆ</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
            background: #000;
            color: #fff;
            line-height: 1;
            padding: 8px;
            width: 150px;
            overflow-x: hidden;
        }

        #searchContainer {
            margin-bottom: 8px;
            position: sticky;
            top: 0;
            z-index: 100;
            background: #000;
        }

        #marketInput {
            width: 100%;
            padding: 4px 6px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 3px;
            color: #fff;
            font-size: 11px;
            font-family: inherit;
            transition: border-color 0.15s;
        }

        #marketInput:focus {
            outline: none;
            border-color: #0066ff;
        }

        #marketInput::placeholder {
            color: #666;
        }

        #addBtn {
            display: none;
        }

        #marketsContainer {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .market-row {
            display: flex;
            align-items: center;
            height: 10px;
            font-size: 9px;
            border-bottom: 1px solid #1a1a1a;
            padding: 0 4px;
            gap: 4px;
            transition: background 0.1s;
        }

        .market-row:hover {
            background: #1a1a1a;
        }

        .market-price {
            color: #0066ff;
            font-weight: 600;
            min-width: 20px;
            text-align: right;
            flex-shrink: 0;
            text-shadow: 0 0 8px rgba(0, 102, 255, 0.5);
        }

        .market-price.updating {
            animation: priceUpdate 0.6s ease-in-out;
        }

        @keyframes priceUpdate {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        .market-slug {
            color: #fff;
            flex: 1;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            font-size: 8px;
            text-align: right;
        }

        .market-row.loading .market-price {
            color: #666;
            animation: pulse 1.5s infinite;
        }

        .market-row.error .market-price {
            color: #ff4444;
        }

        .remove-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 8px;
            padding: 0;
            width: 6px;
            height: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: color 0.1s, opacity 0.1s;
            flex-shrink: 0;
        }

        .market-row:hover .remove-btn {
            opacity: 1;
        }

        .remove-btn:hover {
            color: #ff4444;
        }

        .empty-state {
            font-size: 8px;
            color: #666;
            text-align: center;
            padding: 20px 4px;
            line-height: 1.4;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Hide elements not in watchlist */
        .settings,
        .help-text,
        header,
        .controls {
            display: none;
        }
    </style>
</head>
<body>
    <div id="searchContainer">
        <input 
            type="text" 
            id="marketInput" 
            placeholder="slug"
            autocomplete="off"
        >
    </div>
    <div id="marketsContainer"></div>
    <button id="addBtn" style="display:none;"></button>
    <button id="refreshBtn" style="display:none;"></button>

    <script>
        // Configuration
        const CONFIG = {
            // When deployed on Netlify, this will be /api/polymarket
            // When testing locally, you need to run the function locally or use the direct API
            API_ENDPOINT: '/.netlify/functions/polymarket',
            STORAGE_KEY: 'polymarket_markets'
        };

        // State
        let markets = [];
        let refreshInterval = 30;
        let autoRefreshTimer = null;

        // Initialize app
        function init() {
            loadMarkets();
            setupEventListeners();
            startAutoRefresh();
            renderMarkets();
        }

        // Event Listeners
        function setupEventListeners() {
            document.getElementById('addBtn').addEventListener('click', addMarket);
            document.getElementById('marketInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addMarket();
            });
            document.getElementById('refreshBtn').addEventListener('click', refreshAllMarkets);
            document.getElementById('refreshInterval').addEventListener('change', (e) => {
                refreshInterval = parseInt(e.target.value);
                restartAutoRefresh();
            });
        }

        // Add market
        function addMarket() {
            const input = document.getElementById('marketInput');
            const slug = input.value.trim();

            if (!slug) {
                alert('Please enter a market or event slug');
                return;
            }

            // First, try to fetch as an event to see if it has multiple markets
            checkIfEventAndShowMarkets(slug);
            input.value = '';
        }

        // Check if slug is an event with multiple markets
        async function checkIfEventAndShowMarkets(slug) {
            try {
                const response = await fetch(
                    `${CONFIG.API_ENDPOINT}?slug=${encodeURIComponent(slug)}`
                );

                if (!response.ok) {
                    alert('Market/event not found');
                    return;
                }

                const responseData = await response.json();
                const data = responseData.data || responseData;

                // Check if it's an event with multiple markets
                if (Array.isArray(data) && data.length > 0) {
                    const eventData = data[0];
                    
                    // If it has a markets array with multiple items, show selection UI
                    if (eventData.markets && Array.isArray(eventData.markets) && eventData.markets.length > 1) {
                        showMarketSelector(eventData);
                        return;
                    } else if (eventData.markets && eventData.markets.length === 1) {
                        // Only one market, ask for custom name
                        showCustomNamePrompt(eventData.markets[0].slug);
                        return;
                    }
                }

                // If we get here, it's a binary market (not an event), ask for custom name
                showCustomNamePrompt(slug);
            } catch (error) {
                console.error('Error checking if event:', error);
                // If there's an error, assume it's a binary market and ask for custom name
                showCustomNamePrompt(slug);
            }
        }

        // Show a modal to select which market from an event
        function showMarketSelector(eventData) {
            const markets = eventData.markets || [];
            
            // Create a simple popup menu
            const marketList = markets
                .map(m => `<button class="market-option-btn" data-slug="${m.slug}">${m.title}</button>`)
                .join('');

            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            modal.innerHTML = `
                <div style="
                    background: var(--bg-card);
                    border: 1px solid var(--border);
                    border-radius: 12px;
                    padding: 24px;
                    max-width: 400px;
                    max-height: 80vh;
                    overflow-y: auto;
                ">
                    <h2 style="margin-bottom: 16px; font-size: 18px;">Select a Market</h2>
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
                        "${eventData.title}" has ${markets.length} markets. Choose one to track:
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        ${marketList}
                    </div>
                    <button id="cancelBtn" style="
                        width: 100%;
                        margin-top: 16px;
                        padding: 10px;
                        background: var(--border);
                        color: var(--text-primary);
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                    ">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);

            // Add event listeners
            modal.querySelectorAll('.market-option-btn').forEach(btn => {
                btn.style.cssText = `
                    padding: 12px;
                    background: var(--primary);
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    text-align: left;
                    transition: background 0.2s;
                    font-size: 14px;
                `;
                btn.addEventListener('mouseover', () => btn.style.background = 'var(--primary-dark)');
                btn.addEventListener('mouseout', () => btn.style.background = 'var(--primary)');
                btn.addEventListener('click', () => {
                    const marketSlug = btn.dataset.slug;
                    modal.remove();
                    showCustomNamePrompt(marketSlug);
                });
            });

            document.getElementById('cancelBtn').addEventListener('click', () => {
                modal.remove();
            });

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Show prompt for custom name
        function showCustomNamePrompt(slug) {
            const customName = prompt('Custom name for this market:', slug);
            if (customName !== null && customName.trim() !== '') {
                addMarketToList(slug, customName.trim());
            } else if (customName !== null) {
                // User clicked OK but left it blank, use slug
                addMarketToList(slug, slug);
            }
            // If user clicked Cancel (null), do nothing
        }

        // Add a market to the list
        function addMarketToList(slug, customName = null) {
            if (markets.some(m => m.slug === slug)) {
                alert('This market is already being tracked');
                return;
            }

            const market = {
                id: Date.now().toString(),
                slug: slug,
                displayName: customName || slug,
                yesPrice: null,
                noPrice: null,
                lastUpdated: null,
                error: null,
                loading: true
            };

            markets.push(market);
            saveMarkets();
            renderMarkets();
            
            // Fetch data immediately
            updateMarket(market.id);
        }

        // Remove market
        function removeMarket(id) {
            markets = markets.filter(m => m.id !== id);
            saveMarkets();
            renderMarkets();
        }

        // Fetch market data from Polymarket API
        async function updateMarket(marketId) {
            const market = markets.find(m => m.id === marketId);
            if (!market) return;

            market.loading = true;
            market.error = null;
            renderMarkets();

            try {
                // Fetch market data through our Netlify serverless function
                const response = await fetch(
                    `${CONFIG.API_ENDPOINT}?slug=${encodeURIComponent(market.slug)}`
                );

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const responseData = await response.json();
                
                console.log("=== FULL RESPONSE ===");
                console.log(JSON.stringify(responseData, null, 2));
                console.log("=== END RESPONSE ===");

                // Extract the actual data
                const data = responseData.data || responseData;
                const source = responseData.source || 'unknown';

                console.log(`Source: ${source}`);
                console.log("Data to parse:", data);

                if (!data) {
                    throw new Error('No data returned from API');
                }

                // Handle strapi format (array of events)
                if (Array.isArray(data)) {
                    console.log("Response is an array with", data.length, "items");
                    
                    if (data.length === 0) {
                        throw new Error('Market not found (empty array)');
                    }
                    
                    const eventData = data[0];
                    console.log("First item:", eventData);
                    
                    if (eventData.title) market.title = eventData.title;
                    
                    if (eventData.outcomePrices) {
                        const prices = typeof eventData.outcomePrices === 'string'
                            ? JSON.parse(eventData.outcomePrices)
                            : eventData.outcomePrices;
                        
                        console.log("Parsed prices:", prices);
                        
                        if (Array.isArray(prices) && prices.length >= 2) {
                            market.yesPrice = Math.max(0, Math.min(1, parseFloat(prices[0]) || 0));
                            market.noPrice = Math.max(0, Math.min(1, parseFloat(prices[1]) || 0));
                        } else {
                            throw new Error('Invalid price format: ' + JSON.stringify(prices));
                        }
                    } else {
                        throw new Error('No outcomePrices field. Available fields: ' + Object.keys(eventData).join(', '));
                    }
                }
                // Handle gamma-api format (object with data array)
                else if (data.data && Array.isArray(data.data)) {
                    console.log("Response has data.data array with", data.data.length, "items");
                    
                    if (data.data.length === 0) {
                        throw new Error('Market not found (empty data array)');
                    }
                    
                    const marketData = data.data[0];
                    console.log("First market:", marketData);
                    
                    market.title = marketData.title || market.slug;

                    if (marketData.outcomes && Array.isArray(marketData.outcomes)) {
                        console.log("Found outcomes array with", marketData.outcomes.length, "items");
                        
                        if (marketData.outcomes.length >= 2) {
                            const yesOutcome = marketData.outcomes.find(o => o.name === 'Yes') || marketData.outcomes[0];
                            const noOutcome = marketData.outcomes.find(o => o.name === 'No') || marketData.outcomes[1];

                            market.yesPrice = Math.max(0, Math.min(1, parseFloat(yesOutcome.price) || 0));
                            market.noPrice = Math.max(0, Math.min(1, parseFloat(noOutcome.price) || 0));
                        } else {
                            throw new Error('Not enough outcomes');
                        }
                    } else {
                        throw new Error('No outcomes field. Available fields: ' + Object.keys(marketData).join(', '));
                    }
                } else {
                    console.log("Data type:", typeof data);
                    console.log("Data keys:", data ? Object.keys(data).join(', ') : 'null');
                    throw new Error('Unexpected response format. Data structure: ' + JSON.stringify(data).substring(0, 200));
                }

                market.lastUpdated = new Date();
                market.error = null;
            } catch (error) {
                market.error = error.message;
                market.yesPrice = null;
                market.noPrice = null;
            } finally {
                market.loading = false;
                renderMarkets();
                
                // Trigger fade animation on the price
                setTimeout(() => {
                    const priceElement = document.querySelector(`[data-id="${market.id}"] .market-price`);
                    if (priceElement) {
                        priceElement.classList.add('updating');
                        setTimeout(() => {
                            priceElement.classList.remove('updating');
                        }, 600);
                    }
                }, 0);
            }
        }

        // Refresh all markets
        async function refreshAllMarkets() {
            document.getElementById('refreshBtn').disabled = true;
            await Promise.all(markets.map(m => updateMarket(m.id)));
            document.getElementById('refreshBtn').disabled = false;
        }

        // Auto-refresh setup
        function startAutoRefresh() {
            autoRefreshTimer = setInterval(refreshAllMarkets, refreshInterval * 1000);
        }

        function restartAutoRefresh() {
            if (autoRefreshTimer) clearInterval(autoRefreshTimer);
            startAutoRefresh();
        }

        // Storage
        function saveMarkets() {
            const toSave = markets.map(m => ({
                slug: m.slug,
                id: m.id,
                displayName: m.displayName
            }));
            localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(toSave));
        }

        function loadMarkets() {
            try {
                const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    markets = parsed.map(m => ({
                        id: m.id,
                        slug: m.slug,
                        displayName: m.displayName || m.slug,
                        yesPrice: null,
                        noPrice: null,
                        lastUpdated: null,
                        error: null,
                        loading: true
                    }));
                    
                    // Fetch fresh data for all loaded markets
                    markets.forEach(m => updateMarket(m.id));
                }
            } catch (e) {
                console.error('Error loading saved markets:', e);
                markets = [];
            }
        }

        // Render
        function renderMarkets() {
            const container = document.getElementById('marketsContainer');

            if (markets.length === 0) {
                container.innerHTML = `<div class="empty-state">type slug</div>`;
                return;
            }

            container.innerHTML = markets.map(renderMarketRow).join('');

            // Re-attach remove listeners
            document.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeMarket(btn.dataset.id);
                });
            });
        }

        function renderMarketRow(market) {
            const { id, slug, displayName, yesPrice, loading, error } = market;

            if (error) {
                return `
                    <div class="market-row error" data-id="${id}">
                        <div class="market-price">!</div>
                        <div class="market-slug" title="${displayName}">${displayName}</div>
                        <button class="remove-btn" data-id="${id}">Ã—</button>
                    </div>
                `;
            }

            if (loading || yesPrice === null) {
                return `
                    <div class="market-row loading" data-id="${id}">
                        <div class="market-price">-</div>
                        <div class="market-slug" title="${displayName}">${displayName}</div>
                        <button class="remove-btn" data-id="${id}">Ã—</button>
                    </div>
                `;
            }

            return `
                <div class="market-row" data-id="${id}">
                    <div class="market-price">${(yesPrice * 100).toFixed(0)}</div>
                    <div class="market-slug" title="${displayName}">${displayName}</div>
                    <button class="remove-btn" data-id="${id}">Ã—</button>
                </div>
            `;
        }

        function formatTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            return 'a while ago';
        }

        // Start the app
        init();
    </script>
</body>
</html>